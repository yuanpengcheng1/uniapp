'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const node_fs = require('node:fs');
const chokidar = require('chokidar');
const utils = require('./shared/vite-plugin-uni-components.67336b34.cjs');
const node_path = require('node:path');
const Debug = require('debug');
const utils$1 = require('@antfu/utils');
const localPkg = require('local-pkg');
const fg = require('fast-glob');
const path = require('path');
const fs = require('fs');
const promises = require('fs/promises');
const MagicString = require('magic-string');
require('minimatch');
require('resolve');

function _interopDefaultCompat (e) { return e && typeof e === 'object' && 'default' in e ? e.default : e; }

const chokidar__default = /*#__PURE__*/_interopDefaultCompat(chokidar);
const Debug__default = /*#__PURE__*/_interopDefaultCompat(Debug);
const fg__default = /*#__PURE__*/_interopDefaultCompat(fg);
const MagicString__default = /*#__PURE__*/_interopDefaultCompat(MagicString);

const defaultOptions = {
  dirs: "src/components",
  extensions: "vue",
  deep: true,
  dts: localPkg.isPackageExists("typescript"),
  directoryAsNamespace: false,
  collapseSamePrefixes: false,
  globalNamespaces: [],
  resolvers: [],
  importPathTransform: (v) => v,
  allowOverrides: false
};
function normalizeResolvers(resolvers) {
  return utils$1.toArray(resolvers).flat().map((r) => typeof r === "function" ? { resolve: r, type: "component" } : r);
}
function resolveOptions(options, root) {
  const resolved = Object.assign({}, defaultOptions, options);
  resolved.resolvers = normalizeResolvers(resolved.resolvers);
  resolved.extensions = utils$1.toArray(resolved.extensions);
  if (resolved.globs) {
    resolved.globs = utils$1.toArray(resolved.globs).map((glob) => utils$1.slash(node_path.resolve(root, glob)));
    resolved.resolvedDirs = [];
  } else {
    const extsGlob = resolved.extensions.length === 1 ? resolved.extensions : `{${resolved.extensions.join(",")}}`;
    resolved.dirs = utils$1.toArray(resolved.dirs);
    resolved.resolvedDirs = resolved.dirs.map((i) => utils$1.slash(node_path.resolve(root, i)));
    resolved.globs = resolved.resolvedDirs.map(
      (i) => resolved.deep ? utils$1.slash(node_path.join(i, `**/*.${extsGlob}`)) : utils$1.slash(node_path.join(i, `*.${extsGlob}`))
    );
    if (!resolved.extensions.length)
      throw new Error("[vite-plugin-uni-components] `extensions` option is required to search for components");
  }
  resolved.dts = !resolved.dts ? false : node_path.resolve(
    root,
    typeof resolved.dts === "string" ? resolved.dts : "components.d.ts"
  );
  resolved.types = resolved.types || [];
  resolved.root = root;
  resolved.version = resolved.version ?? getVueVersion(root);
  if (resolved.version < 2 || resolved.version >= 4)
    throw new Error(`[vite-plugin-uni-components] unsupported version: ${resolved.version}`);
  resolved.transformer = options.transformer || `vue${Math.trunc(resolved.version)}`;
  resolved.directives = typeof options.directives === "boolean" ? options.directives : !resolved.resolvers.some((i) => i.type === "directive") ? false : resolved.version >= 3;
  return resolved;
}
function getVueVersion(root) {
  const raw = localPkg.getPackageInfoSync("vue", { paths: [root] })?.version || "3";
  const version = +raw.split(".").slice(0, 2).join(".");
  if (version === 2.7)
    return 2.7;
  else if (version < 2.7)
    return 2;
  return 3;
}

const debug$4 = Debug__default("vite-plugin-uni-components:glob");
function searchComponents(ctx) {
  debug$4(`started with: [${ctx.options.globs.join(", ")}]`);
  const root = ctx.root;
  const files = fg__default.sync(ctx.options.globs, {
    ignore: ["node_modules"],
    onlyFiles: true,
    cwd: root,
    absolute: true
  });
  if (!files.length && !ctx.options.resolvers?.length)
    console.warn("[vite-plugin-uni-components] no components found");
  debug$4(`${files.length} components found.`);
  ctx.addComponents(files);
}

const multilineCommentsRE = /\/\*.*?\*\//gms;
const singlelineCommentsRE = /\/\/.*$/gm;
function extractImports(code) {
  return Object.fromEntries(Array.from(code.matchAll(/['"]?([^\s'"]+)['"]?\s*:\s*(.+?)[,;\n]/g)).map((i) => [i[1], i[2]]));
}
function parseDeclaration(code) {
  if (!code)
    return;
  code = code.replace(multilineCommentsRE, "").replace(singlelineCommentsRE, "");
  const imports = {
    component: {},
    directive: {}
  };
  const componentDeclaration = /export\s+interface\s+GlobalComponents\s*{(.*?)}/s.exec(code)?.[0];
  if (componentDeclaration)
    imports.component = extractImports(componentDeclaration);
  const directiveDeclaration = /export\s+interface\s+ComponentCustomProperties\s*{(.*?)}/s.exec(code)?.[0];
  if (directiveDeclaration)
    imports.directive = extractImports(directiveDeclaration);
  return imports;
}
function stringifyComponentInfo(filepath, { from: path$1, as: name, name: importName }, importPathTransform) {
  if (!name)
    return void 0;
  path$1 = utils.getTransformedPath(path$1, importPathTransform);
  const related = path.isAbsolute(path$1) ? `./${path.relative(path.dirname(filepath), path$1)}` : path$1;
  const entry = `typeof import('${utils$1.slash(related)}')['default']`;
  return [name, entry];
}
function stringifyComponentsInfo(filepath, components, importPathTransform) {
  return Object.fromEntries(
    components.map((info) => stringifyComponentInfo(filepath, info, importPathTransform)).filter(utils$1.notNullish)
  );
}
function getDeclarationImports(ctx, filepath) {
  const component = stringifyComponentsInfo(filepath, [
    ...Object.values({
      ...ctx.componentNameMap,
      ...ctx.componentCustomMap
    })
  ], ctx.options.importPathTransform);
  const directive = stringifyComponentsInfo(
    filepath,
    Object.values(ctx.directiveCustomMap),
    ctx.options.importPathTransform
  );
  if (Object.keys(component).length + Object.keys(directive).length === 0)
    return;
  return { component, directive };
}
function stringifyDeclarationImports(imports) {
  return Object.entries(imports).sort(([a], [b]) => a.localeCompare(b)).map(([name, v]) => {
    if (!/^\w+$/.test(name))
      name = `'${name}'`;
    return `${name}: ${v}`;
  });
}
function getDeclaration(ctx, filepath, originalImports) {
  const imports = getDeclarationImports(ctx, filepath);
  if (!imports)
    return;
  const declarations = {
    component: stringifyDeclarationImports({ ...originalImports?.component, ...imports.component }),
    directive: stringifyDeclarationImports({ ...originalImports?.directive, ...imports.directive })
  };
  const head = ctx.options.version >= 2.7 ? `export {}

declare module 'vue' {` : `import '@vue/runtime-core'

export {}

declare module '@vue/runtime-core' {`;
  let code = `/* eslint-disable */
/* prettier-ignore */
// @ts-nocheck
// Generated by vite-plugin-uni-components
// Read more: https://github.com/vuejs/core/pull/3399
${head}`;
  if (Object.keys(declarations.component).length > 0) {
    code += `
  export interface GlobalComponents {
    ${declarations.component.join("\n    ")}
  }`;
  }
  if (Object.keys(declarations.directive).length > 0) {
    code += `
  export interface ComponentCustomProperties {
    ${declarations.directive.join("\n    ")}
  }`;
  }
  code += "\n}\n";
  return code;
}
async function writeFile(filePath, content) {
  await promises.mkdir(path.dirname(filePath), { recursive: true });
  return await promises.writeFile(filePath, content, "utf-8");
}
async function writeDeclaration(ctx, filepath, removeUnused = false) {
  const originalContent = fs.existsSync(filepath) ? await promises.readFile(filepath, "utf-8") : "";
  const originalImports = removeUnused ? void 0 : parseDeclaration(originalContent);
  const code = getDeclaration(ctx, filepath, originalImports);
  if (!code)
    return;
  if (code !== originalContent)
    await writeFile(filepath, code);
}

const debug$3 = Debug__default("vite-plugin-uni-components:transform:component");
const resolveVue2$1 = (code, s) => {
  const results = [];
  for (const match of code.matchAll(/\b(_c|h)\([\s\n\t]*['"](.+?)["']([,)])/g)) {
    const [full, renderFunctionName, matchedName, append] = match;
    if (match.index != null && matchedName && !matchedName.startsWith("_")) {
      const start = match.index;
      const end = start + full.length;
      results.push({
        rawName: matchedName,
        replace: (resolved) => s.overwrite(start, end, `${renderFunctionName}(${resolved}${append}`)
      });
    }
  }
  return results;
};
const resolveVue3$1 = (code, s) => {
  const results = [];
  for (const match of code.matchAll(/_resolveComponent[0-9]*\("(.+?)"\)/g)) {
    const matchedName = match[1];
    if (match.index != null && matchedName && !matchedName.startsWith("_")) {
      const start = match.index;
      const end = start + match[0].length;
      results.push({
        rawName: matchedName,
        replace: (resolved) => s.overwrite(start, end, resolved)
      });
    }
  }
  return results;
};
async function transformComponent(code, transformer, s, ctx, sfcPath) {
  let no = 0;
  const results = transformer === "vue2" ? resolveVue2$1(code, s) : resolveVue3$1(code, s);
  for (const { rawName, replace } of results) {
    debug$3(`| ${rawName}`);
    const name = utils.pascalCase(rawName);
    ctx.updateUsageMap(sfcPath, [name]);
    const component = await ctx.findComponent(name, "component", [sfcPath]);
    if (component) {
      const varName = `__unplugin_components_${no}`;
      s.prepend(`${utils.stringifyComponentImport({ ...component, as: varName }, ctx)};
`);
      no += 1;
      replace(varName);
    }
  }
  debug$3(`^ (${no})`);
}

const getRenderFnStart = (program) => {
  const renderFn = program.body.find(
    (node) => node.type === "VariableDeclaration" && node.declarations[0].id.type === "Identifier" && ["render", "_sfc_render"].includes(node.declarations[0].id.name)
  );
  const start = renderFn?.declarations[0].init?.body?.start;
  if (start === null || start === void 0)
    throw new Error("[vite-plugin-uni-components:directive] Cannot find render function position.");
  return start + 1;
};
async function resolveVue2(code, s) {
  if (!localPkg.isPackageExists("@babel/parser"))
    throw new Error('[vite-plugin-uni-components:directive] To use Vue 2 directive you will need to install Babel first: "npm install -D @babel/parser"');
  const { parse } = await localPkg.importModule("@babel/parser");
  const { program } = parse(code, {
    sourceType: "module"
  });
  const nodes = [];
  const { walk } = await import('estree-walker');
  walk(program, {
    enter(node) {
      if (node.type === "CallExpression")
        nodes.push(node);
    }
  });
  if (nodes.length === 0)
    return [];
  let _renderStart;
  const getRenderStart = () => {
    if (_renderStart !== void 0)
      return _renderStart;
    return _renderStart = getRenderFnStart(program);
  };
  const results = [];
  for (const node of nodes) {
    const { callee, arguments: args } = node;
    if (callee.type !== "Identifier" || callee.name !== "_c" || args[1]?.type !== "ObjectExpression")
      continue;
    const directives = args[1].properties.find(
      (property) => property.type === "ObjectProperty" && property.key.type === "Identifier" && property.key.name === "directives"
    )?.value;
    if (!directives || directives.type !== "ArrayExpression")
      continue;
    for (const directive of directives.elements) {
      if (directive?.type !== "ObjectExpression")
        continue;
      const nameNode = directive.properties.find(
        (p) => p.type === "ObjectProperty" && p.key.type === "Identifier" && p.key.name === "name"
      )?.value;
      if (nameNode?.type !== "StringLiteral")
        continue;
      const name = nameNode.value;
      if (!name || name.startsWith("_"))
        continue;
      results.push({
        rawName: name,
        replace: (resolved) => {
          s.prependLeft(getRenderStart(), `
this.$options.directives["${name}"] = ${resolved};`);
        }
      });
    }
  }
  return results;
}

function resolveVue3(code, s) {
  const results = [];
  for (const match of code.matchAll(/_resolveDirective\("(.+?)"\)/g)) {
    const matchedName = match[1];
    if (match.index != null && matchedName && !matchedName.startsWith("_")) {
      const start = match.index;
      const end = start + match[0].length;
      results.push({
        rawName: matchedName,
        replace: (resolved) => s.overwrite(start, end, resolved)
      });
    }
  }
  return results;
}

const debug$2 = Debug__default("vite-plugin-uni-components:transform:directive");
async function transformDirective(code, transformer, s, ctx, sfcPath) {
  let no = 0;
  const results = await (transformer === "vue2" ? resolveVue2(code, s) : resolveVue3(code, s));
  for (const { rawName, replace } of results) {
    debug$2(`| ${rawName}`);
    const name = `${utils.DIRECTIVE_IMPORT_PREFIX}${utils.pascalCase(rawName)}`;
    ctx.updateUsageMap(sfcPath, [name]);
    const directive = await ctx.findComponent(name, "directive", [sfcPath]);
    if (!directive)
      continue;
    const varName = `__unplugin_directives_${no}`;
    s.prepend(`${utils.stringifyComponentImport({ ...directive, as: varName }, ctx)};
`);
    no += 1;
    replace(varName);
  }
  debug$2(`^ (${no})`);
}

const debug$1 = Debug__default("vite-plugin-uni-components:transformer");
function transformer(ctx, transformer2) {
  return async (code, id, path) => {
    ctx.searchGlob();
    const sfcPath = ctx.normalizePath(path);
    debug$1(sfcPath);
    const s = new MagicString__default(code);
    await transformComponent(code, transformer2, s, ctx, sfcPath);
    if (ctx.options.directives)
      await transformDirective(code, transformer2, s, ctx, sfcPath);
    s.prepend(utils.DISABLE_COMMENT);
    const result = { code: s.toString() };
    if (ctx.sourcemap)
      result.map = s.generateMap({ source: id, includeContent: true });
    return result;
  };
}

const debug = {
  components: Debug__default("vite-plugin-uni-components:context:components"),
  search: Debug__default("vite-plugin-uni-components:context:search"),
  hmr: Debug__default("vite-plugin-uni-components:context:hmr"),
  decleration: Debug__default("vite-plugin-uni-components:decleration"),
  env: Debug__default("vite-plugin-uni-components:env")
};
class Context {
  constructor(rawOptions) {
    this.rawOptions = rawOptions;
    this.transformer = void 0;
    this._componentPaths = /* @__PURE__ */ new Set();
    this._componentNameMap = {};
    this._componentUsageMap = {};
    this._componentCustomMap = {};
    this._directiveCustomMap = {};
    this.root = process.cwd();
    this.sourcemap = true;
    this.alias = {};
    this._searched = false;
    this.options = resolveOptions(rawOptions, this.root);
    this.generateDeclaration = utils$1.throttle(500, this._generateDeclaration.bind(this), { noLeading: false });
    this.setTransformer(this.options.transformer);
  }
  setRoot(root) {
    if (this.root === root)
      return;
    debug.env("root", root);
    this.root = root;
    this.options = resolveOptions(this.rawOptions, this.root);
  }
  setTransformer(name) {
    debug.env("transformer", name);
    this.transformer = transformer(this, name || "vue3");
  }
  transform(code, id) {
    const { path, query } = utils.parseId(id);
    return this.transformer(code, id, path, query);
  }
  setupViteServer(server) {
    if (this._server === server)
      return;
    this._server = server;
    this.setupWatcher(server.watcher);
  }
  setupWatcher(watcher) {
    const { globs } = this.options;
    watcher.on("unlink", (path) => {
      if (!utils.matchGlobs(path, globs))
        return;
      path = utils$1.slash(path);
      this.removeComponents(path);
      this.onUpdate(path);
    });
    watcher.on("add", (path) => {
      if (!utils.matchGlobs(path, globs))
        return;
      path = utils$1.slash(path);
      this.addComponents(path);
      this.onUpdate(path);
    });
  }
  /**
   * Record the usage of components
   * @param path
   * @param paths paths of used components
   */
  updateUsageMap(path, paths) {
    if (!this._componentUsageMap[path])
      this._componentUsageMap[path] = /* @__PURE__ */ new Set();
    paths.forEach((p) => {
      this._componentUsageMap[path].add(p);
    });
  }
  addComponents(paths) {
    debug.components("add", paths);
    const size = this._componentPaths.size;
    utils$1.toArray(paths).forEach((p) => this._componentPaths.add(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  addCustomComponents(info) {
    if (info.as)
      this._componentCustomMap[info.as] = info;
  }
  addCustomDirectives(info) {
    if (info.as)
      this._directiveCustomMap[info.as] = info;
  }
  removeComponents(paths) {
    debug.components("remove", paths);
    const size = this._componentPaths.size;
    utils$1.toArray(paths).forEach((p) => this._componentPaths.delete(p));
    if (this._componentPaths.size !== size) {
      this.updateComponentNameMap();
      return true;
    }
    return false;
  }
  onUpdate(path) {
    this.generateDeclaration();
    if (!this._server)
      return;
    const payload = {
      type: "update",
      updates: []
    };
    const timestamp = +/* @__PURE__ */ new Date();
    const name = utils.pascalCase(utils.getNameFromFilePath(path, this.options));
    Object.entries(this._componentUsageMap).forEach(([key, values]) => {
      if (values.has(name)) {
        const r = `/${utils$1.slash(node_path.relative(this.root, key))}`;
        payload.updates.push({
          acceptedPath: r,
          path: r,
          timestamp,
          type: "js-update"
        });
      }
    });
    if (payload.updates.length)
      this._server.ws.send(payload);
  }
  updateComponentNameMap() {
    this._componentNameMap = {};
    Array.from(this._componentPaths).forEach((path) => {
      const name = utils.pascalCase(utils.getNameFromFilePath(path, this.options));
      if (utils.isExclude(name, this.options.excludeNames)) {
        debug.components("exclude", name);
        return;
      }
      if (this._componentNameMap[name] && !this.options.allowOverrides) {
        console.warn(`[vite-plugin-uni-components] component "${name}"(${path}) has naming conflicts with other components, ignored.`);
        return;
      }
      this._componentNameMap[name] = {
        as: name,
        from: path
      };
    });
  }
  async findComponent(name, type, excludePaths = []) {
    let info = this._componentNameMap[name];
    if (info && !excludePaths.includes(info.from) && !excludePaths.includes(info.from.slice(1)))
      return info;
    for (const resolver of this.options.resolvers) {
      if (resolver.type !== type)
        continue;
      const result = await resolver.resolve(type === "directive" ? name.slice(utils.DIRECTIVE_IMPORT_PREFIX.length) : name);
      if (!result)
        continue;
      if (typeof result === "string") {
        info = {
          as: name,
          from: result
        };
      } else {
        info = {
          as: name,
          ...utils.normalizeComponetInfo(result)
        };
      }
      if (type === "component")
        this.addCustomComponents(info);
      else if (type === "directive")
        this.addCustomDirectives(info);
      return info;
    }
    return void 0;
  }
  normalizePath(path) {
    return utils.resolveAlias(path, this.viteConfig?.resolve?.alias || this.viteConfig?.alias || []);
  }
  relative(path) {
    if (path.startsWith("/") && !path.startsWith(this.root))
      return utils$1.slash(path.slice(1));
    return utils$1.slash(node_path.relative(this.root, path));
  }
  /**
   * This search for components in with the given options.
   * Will be called multiple times to ensure file loaded,
   * should normally run only once.
   */
  searchGlob() {
    if (this._searched)
      return;
    searchComponents(this);
    debug.search(this._componentNameMap);
    this._searched = true;
  }
  _generateDeclaration(removeUnused = !this._server) {
    if (!this.options.dts)
      return;
    debug.decleration("generating");
    return writeDeclaration(this, this.options.dts, removeUnused);
  }
  get componentNameMap() {
    return this._componentNameMap;
  }
  get componentCustomMap() {
    return this._componentCustomMap;
  }
  get directiveCustomMap() {
    return this._directiveCustomMap;
  }
}

function VitePluginComponents(options = {}) {
  const ctx = new Context(options);
  return {
    name: "vite-plugin-uni-components",
    enforce: "post",
    configResolved(config) {
      ctx.setRoot(config.root);
      ctx.sourcemap = true;
      if (config.plugins.find((i) => i.name === "vite-plugin-vue2"))
        ctx.setTransformer("vue2");
      if (ctx.options.dts) {
        ctx.searchGlob();
        if (!node_fs.existsSync(ctx.options.dts))
          ctx.generateDeclaration();
      }
      if (config.build.watch && config.command === "build")
        ctx.setupWatcher(chokidar__default.watch(ctx.options.globs));
    },
    configureServer(server) {
      ctx.setupViteServer(server);
    },
    async transform(code, id) {
      if (!utils.shouldTransform(code))
        return null;
      try {
        const result = await ctx.transform(code, id);
        ctx.generateDeclaration();
        return result;
      } catch (e) {
        this.error(e);
      }
    }
  };
}

exports.camelCase = utils.camelCase;
exports.kebabCase = utils.kebabCase;
exports.pascalCase = utils.pascalCase;
exports.default = VitePluginComponents;
